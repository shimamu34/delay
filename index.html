<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>web遅延ツール</title>

<style>
  :root { --bg:#000; --fg:#fff; --ui:#1f2937; --accent:#22c55e; }
  html, body { margin:0; padding:0; background:var(--bg); color:var(--fg); height:100%; }
  #wrap { display:flex; flex-direction:column; height:100%; }
  #view { flex:1; display:flex; align-items:center; justify-content:center; overflow:hidden; background:#000; position:relative; }
  canvas { max-width:100%; max-height:100%; }
  #panel { background:rgba(31,41,55,.9); padding:8px 10px; display:flex; flex-wrap:wrap; gap:8px; align-items:center; font-size:14px; }
  label { display:flex; align-items:center; gap:6px; }
  input[type=range] { min-width:120px; }
  button { background:#111827; color:#fff; border:1px solid #374151; padding:6px 10px; border-radius:6px; cursor:pointer; }
  button:disabled { opacity:.5; cursor:not-allowed; }
  button.accent { border-color:var(--accent); color:var(--accent); }
  select { background:#111827; color:#fff; border:1px solid #374151; border-radius:6px; padding:4px; }
  #countdown { position:absolute; top:10px; right:10px; font-size:32px; font-weight:bold; color:red; text-shadow:0 0 4px #000; }
  #status { position:absolute; top:10px; left:10px; font-size:14px; background:rgba(0,0,0,.7); padding:4px 8px; border-radius:4px; }
</style>
</head>
<body>
<div id="wrap">
  <div id="view">
    <canvas id="canvas"></canvas>
    <div id="countdown"></div>
    <div id="status"></div>
  </div>

  <div id="panel">
    <label>カメラ
      <select id="cameraSelect"></select>
    </label>

    <label>解像度
      <select id="resolutionSelect">
        <option value="640x480">SD (640x480)</option>
        <option value="1280x720" selected>HD (1280x720)</option>
        <option value="1920x1080">Full HD (1920x1080)</option>
      </select>
    </label>

    <label>遅延 <strong><span id="dsec">5</span>s</strong>
      <input id="delay" type="range" min="0" max="30" step="1" value="5" />
    </label>

    <label>FPS <strong><span id="fpsv">15</span></strong>
      <input id="fps" type="range" min="10" max="30" step="1" value="15" />
    </label>

    <button id="fs">全画面</button>
    <button id="save" disabled>10秒保存</button>
    <button id="start" class="accent">開始</button>
    <button id="stop" style="display:none">停止</button>
  </div>
</div>

<video id="video" playsinline muted style="display:none"></video>

<script>
// ===== 状態 =====
let delaySeconds = 5;
let delayMs = 5000;
let targetFPS = 15;
let running = false;

let frameBuffer = [];
let lastDraw = 0;

let saving = false;
let saveStart = 0;
let recorder;
let recordedChunks = [];

let selectedDeviceId = null;
let currentStream = null;
let selectedResolution = { width: 1280, height: 720 };

// ===== DOM =====
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const delayInput = document.getElementById('delay');
const fpsInput = document.getElementById('fps');
const dsec = document.getElementById('dsec');
const fpsv = document.getElementById('fpsv');
const fsBtn = document.getElementById('fs');
const startBtn = document.getElementById('start');
const stopBtn = document.getElementById('stop');
const saveBtn = document.getElementById('save');
const countdown = document.getElementById('countdown');
const status = document.getElementById('status');
const cameraSelect = document.getElementById('cameraSelect');
const resolutionSelect = document.getElementById('resolutionSelect');

// ===== カメラ一覧取得 =====
async function setupCameraList() {
  try {
    // まず権限を取得
    await navigator.mediaDevices.getUserMedia({ video: true });
    
    const devices = await navigator.mediaDevices.enumerateDevices();
    const videos = devices.filter(d => d.kind === 'videoinput');

    cameraSelect.innerHTML = '';
    
    // 背面カメラ(environment)を探す
    let backCamera = null;
    
    videos.forEach((d, i) => {
      const opt = document.createElement('option');
      opt.value = d.deviceId;
      
      // ラベルから背面カメラを判定
      const label = d.label.toLowerCase();
      const isBack = label.includes('back') || label.includes('rear') || label.includes('environment');
      const isFront = label.includes('front') || label.includes('user') || label.includes('face');
      
      let displayName = d.label || `カメラ ${i + 1}`;
      if (isBack) displayName += ' (背面)';
      if (isFront) displayName += ' (前面)';
      
      opt.textContent = displayName;
      cameraSelect.appendChild(opt);
      
      // 背面カメラを優先的に選択
      if (isBack && !backCamera) {
        backCamera = d.deviceId;
      }
    });

    if (videos.length) {
      // 背面カメラがあればそれを、なければ最初のカメラを選択
      selectedDeviceId = backCamera || videos[0].deviceId;
      
      // 背面カメラを選択状態にする
      if (backCamera) {
        cameraSelect.value = backCamera;
      }
      
      status.textContent = `${videos.length}台のカメラが見つかりました`;
    } else {
      status.textContent = 'カメラが見つかりません';
    }
  } catch (err) {
    status.textContent = 'カメラアクセス権限が必要です';
    console.error(err);
  }
}

cameraSelect.onchange = async () => {
  const newDeviceId = cameraSelect.value;
  if (running && newDeviceId !== selectedDeviceId) {
    selectedDeviceId = newDeviceId;
    await restartCamera();
  } else {
    selectedDeviceId = newDeviceId;
  }
};

resolutionSelect.onchange = () => {
  const [width, height] = resolutionSelect.value.split('x').map(Number);
  selectedResolution = { width, height };
  
  if (running) {
    restartCamera();
  }
};

// ===== UI =====
delayInput.oninput = () => {
  delaySeconds = Number(delayInput.value);
  delayMs = delaySeconds * 1000;
  dsec.textContent = delaySeconds;
};

fpsInput.oninput = () => {
  targetFPS = Number(fpsInput.value);
  fpsv.textContent = targetFPS;
};

fsBtn.onclick = () => {
  if (!document.fullscreenElement) canvas.requestFullscreen();
  else document.exitFullscreen();
};

startBtn.onclick = async () => {
  if (running) return;
  await startCamera();
  running = true;
  lastDraw = performance.now();
  startBtn.style.display = 'none';
  stopBtn.style.display = 'inline-block';
  saveBtn.disabled = false;
  status.textContent = '録画中';
  requestAnimationFrame(loop);
};

stopBtn.onclick = () => {
  stopCamera();
};

// ===== カメラ起動 =====
async function startCamera() {
  try {
    const constraints = {
      audio: false,
      video: selectedDeviceId 
        ? {
            deviceId: { exact: selectedDeviceId },
            width: { ideal: selectedResolution.width },
            height: { ideal: selectedResolution.height },
            frameRate: { ideal: targetFPS }
          }
        : {
            facingMode: { ideal: 'environment' }, // 背面カメラを優先
            width: { ideal: selectedResolution.width },
            height: { ideal: selectedResolution.height },
            frameRate: { ideal: targetFPS }
          }
    };

    const stream = await navigator.mediaDevices.getUserMedia(constraints);

    currentStream = stream;
    video.srcObject = stream;
    await video.play();

    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    
    status.textContent = `録画中 (${video.videoWidth}x${video.videoHeight})`;
  } catch (err) {
    status.textContent = 'カメラ起動エラー';
    console.error(err);
  }
}

async function restartCamera() {
  stopCamera();
  frameBuffer = [];
  await startCamera();
  running = true;
  lastDraw = performance.now();
  requestAnimationFrame(loop);
}

function stopCamera() {
  running = false;
  if (currentStream) {
    currentStream.getTracks().forEach(track => track.stop());
    currentStream = null;
  }
  video.srcObject = null;
  startBtn.style.display = 'inline-block';
  stopBtn.style.display = 'none';
  saveBtn.disabled = true;
  status.textContent = '停止';
  
  if (saving) stopSave();
}

// ===== メインループ =====
function loop(now) {
  if (!running) return;
  const interval = 1000 / targetFPS;

  if (now - lastDraw >= interval) {
    lastDraw = now;

    const bmp = document.createElement('canvas');
    bmp.width = canvas.width;
    bmp.height = canvas.height;
    bmp.getContext('2d').drawImage(video, 0, 0, bmp.width, bmp.height);

    frameBuffer.push({ time: now, bmp });

    let frame = null;
    while (frameBuffer.length && now - frameBuffer[0].time >= delayMs) {
      frame = frameBuffer.shift();
    }

    if (frame) ctx.drawImage(frame.bmp, 0, 0, canvas.width, canvas.height);

    const maxFrames = targetFPS * delaySeconds * 2;
    if (frameBuffer.length > maxFrames) {
      frameBuffer.splice(0, frameBuffer.length - maxFrames);
    }

    if (saving) {
      const remain = 10 - (now - saveStart) / 1000;
      countdown.textContent = remain > 0 ? Math.ceil(remain) : '';
      if (remain <= 0) stopSave();
    }
  }
  requestAnimationFrame(loop);
}

// ===== 保存 =====
saveBtn.onclick = () => {
  if (!running || saving) return;
  
  recordedChunks = [];
  saving = true;
  saveStart = performance.now();
  saveBtn.disabled = true;

  const stream = canvas.captureStream(targetFPS);
  recorder = new MediaRecorder(stream, { mimeType:'video/webm' });
  recorder.ondataavailable = e => recordedChunks.push(e.data);
  recorder.onstop = () => {
    const blob = new Blob(recordedChunks, { type:'video/webm' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `delay_${Date.now()}.webm`;
    a.click();
    saveBtn.disabled = false;
  };
  recorder.start();
};

function stopSave() {
  saving = false;
  countdown.textContent = '';
  if (recorder && recorder.state !== 'inactive') {
    recorder.stop();
  }
}

// 初期化
fpsv.textContent = targetFPS;
dsec.textContent = delaySeconds;
setupCameraList();
</script>
</body>
</html>
